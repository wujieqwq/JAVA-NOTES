---





---

# JAVASE回顾5继承，方法重载，方法重写，多态


1.继承(extends)

1. 子类拥有父类非 private 的属性、方法。
2. 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。
4. Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
5. 提高了类之间的耦合性(继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差)。

构造器
子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。
如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。
2.实现(implements)
		接口(inteface)

* 没有构造方法
* 所有的方法必须是抽象方法(1.8后可以有默认方法default,static修饰)(1.9后允许将方法定义private)
* 不能包含成员变量，除了 static 和 final 变量
* 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）
* 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）

3.抽象类

1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类

4.方法重载

* 方法名相同
* 方法的参数类型，参数个不一样
* 方法的返回类型可以不相同
* 方法的修饰符可以不相同
* main 方法也可以被重载
* 被重载的方法可以声明新的或更广的检查异常
* 方法能够在同一个类中或者在一个子类中被重载

5.方法重写

* 参数列表必须完全与被重写方法的相同；
* 返回类型必须完全与被重写方法的返回类型相同；
* 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
* 父类的成员方法只能被它的子类重写。
* 声明为final的方法不能被重写。
* 声明为static的方法不能被重写，但是能够被再次声明。
* 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
* 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
* 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
* 构造方法不能被重写。
* 如果不能继承一个方法，则不能重写这个方法。

|     |     |     |
| --- | --- | --- |
| 区别点 | 重载方法 | 重写方法 |
| 参数列表 | 必须修改 | 一定不能修改 |
| 返回类型 | 可以修改 | 一定不能修改 |
| 异常  | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问  | 可以修改 | 一定不能做更严格的限制（可以降低限制） |

6.向上转型

* 属性和方法，父类有的才能保留，子类特有的属性和方法，都消失。
* 如果子类重写了父类的方法，就调用子类重写的方法。否则掉调用父类方法——测试类中，输出a.age，结果为48，说明a的属性指向父类属性，sayAge输出18，说明调用了子类方法。（因为子类中调用age变量，指向的是子类的age=18）

7.向下转型

* 父类对象转换为子类对象，为向下转型，是强制转换。
* 强制向下转型有两种方式：
	* 不安全的向下转型：如`Cat cat = (Cat) new Pet();`编译通过，但运行会抛出异常
	* 安全的向下转型：先向上转型，再向下转型，如`Pet pet = new Cat(); Cat cat = (Cat) pet;`

